/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Not a really useful function, just uses the `receiver` javascript service
 * to get ClusterInfo and LicenceInfo and return them as a Promise<ClusterData>
 *
 * Only to test how to deal with async javascript code using tokio
 */
export function fetchClusterData(receiver: object): Promise<ClusterData>
export interface ClusterData {
  clusterInfo: ESClusterInfo
  licenseInfo: ESLicense
}
export interface EndpointMetadataResult {
  processedEndpoints: number
}
export interface EsClusterInfo {
  cluster_uuid: string
  cluster_name: string
  version?: ESVersion
}
export interface EsVersion {
  number: string
  build_flavor: string
  build_type: string
  build_hash: string
  build_date: string
  build_snapshot?: boolean
  lucene_version: string
  minimum_wire_compatibility_version: string
  minimum_index_compatibility_version: string
}
export interface EsLicense {
  status: string
  uid: string
  type: string
  issue_date?: string
  issue_date_in_millis?: number
  expiry_date?: string
  expiry_date_in_millis?: number
  max_nodes?: number
  issued_to?: string
  issuer?: string
  start_date_in_millis?: number
}
export interface EndpointMetricsAbstract {
  endpointMetricIds: Array<string>
  totalEndpoints: number
}
export interface Agent {
  id: string
  version?: string
}
export interface Event {
  agent_id_status: string
}
export interface PolicyAction {
  name: string
  message: string
  status: string
}
export interface Version {
  version: string
}
export interface Artifact {
  global: Version
}
export interface Policy {
  applied: PolicyApplied
}
export interface PolicyApplied {
  actions: Array<PolicyAction>
  artifacts: Artifact
  status: string
}
export interface NonPolicyConfiguration {
  isolation: boolean
}
export interface Endpoint {
  policy?: Policy
  configuration?: NonPolicyConfiguration
  state?: NonPolicyConfiguration
  capabilities?: Array<string>
}
export interface EndpointPolicyResponseDocument {
  agent: Agent
  event: Event
  Endpoint: Endpoint
}
export interface Elastic {
  agent: Agent
}
export interface EndpointMetadataDocument {
  '@timestamp': string
  agent: Agent
  Endpoint: Endpoint
  elastic: Elastic
}
export interface PackagePolicy {
  id: string
  version?: string
  agents?: number
  revision: number
  updatedAt: string
  updatedBy: string
  createdAt: string
  createdBy: string
}
export interface PackagePolicyInput {
  streams: Array<PackagePolicyInputStream>
}
export interface PackagePolicyInputStream {
  id: string
}
export interface AgentPolicy {
  id: string
  packagePolicies?: Array<PackagePolicy>
  is_managed: boolean
  updated_at: string
  updated_by: string
  revision: number
  agents?: number
  is_protected: boolean
  keep_monitoring_alive?: boolean
  name: string
  namespace: string
  description?: string
  is_default?: boolean
  is_default_fleet_server?: boolean
  has_fleet_server?: boolean
  unenroll_timeout?: number
  inactivity_timeout?: number
  is_preconfigured?: boolean
  data_output_id?: string | null
  monitoring_output_id?: string | null | undefined
  download_source_id?: string | null | undefined
  fleet_server_host_id?: string | null | undefined
  schema_version?: string | null | undefined
}
export interface Elasticsearch {
  privileges: Privileges
}
export interface Privileges {
  cluster: Array<string>
}
export interface PackagePolicyPackage {
  name: string
  title: string
  version: string
  experimental_data_stream_features?: Array<ExperimentalDataStreamFeature>
}
export interface ExperimentalDataStreamFeature {
  data_stream: string
  features: Record<string, boolean>
}
/**
 * Call a non-argument function implemented in javscript
 * Example:
 *
 * import { call0 } from ...;
 *
 * function dummy() {
 *   console.log("Hello, world!");
 * }
 * call0(dummy);
 */
export function call0(callback: () => void): void
/**
 * Call an async function implemented in javascript with a single argument
 * Example:
 *
 * import { call_async } from ...;
 *
 * function dummy(value: number) -> Promise<number> {
 *   return new Promise((resolve) => {
 *   setTimeout(() => resolve(n + 1), 1000)
 * })
 * await call_async(dummy, 99); .// returns 100 after 1 sec
 */
export function callAsync(cb: (arg: number) => Promise<number>, value: number): Promise<i32>
/**
 * Same as above, but this time call <caller>.<fn_name> instead of the getting the function
 * reference as a parameter.
 */
export function callAsyncOnObject(caller: object, fnName: string, value: number): Promise<i32>
export class JsTelemetryModel {
  id: string
  name: string
  value: number
  constructor(id: string, name: string, value: number)
}
export class JsElasticConfig {
  constructor(host: string, username: string, password: string)
}
export class JsElastic {
  constructor(config: JsElasticConfig)
  createIndex(index: string): Promise<void>
  deleteIndex(index: string): Promise<void>
  index(index: string, doc: JsTelemetryModel): Promise<string>
  search(index: string): Promise<Array<JsTelemetryModel>>
}
export class JsTelemetryReceiver {
  constructor(elastic: JsElastic)
  findTelemetryEvents(index: string): Promise<Array<JsTelemetryModel>>
}
